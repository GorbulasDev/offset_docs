
# CSwitch motivation and general idea

02.12.2017

## Introduction

CSwitch is an international communication infrastructure. It allows nodes
to send data packets to each other. To allow fair usage of the networking
resources, CSwitch allows a means of transferring credit between its
nodes.

Differently from the current design of the Internet, sending data packets over
the CSwitch network costs some credit for the sender. This credit is split
between the mediators of the message, and the end receiver. 

The sender, by sending a message, makes other nodes in the network perform work
for him. The mediators need to pass the message, and the receiver of the
message has to open the message and confirm the message receipt.  The credit
paid by the sender of the message is a sort of compensation for all the nodes
involved.

In the CSwitch design, nodes that pass messages through them earn credit. This
could incentivize people that are located in key geographical locations to
build communication infrastructure. In the current Internet only priviledged
people are allowed to start a new ISP (Internet Service Provider). CSwitch
allows anyone to be part of the communication infrastructure and earn credit
for his contribution.

Another advantage is resiliency against DoS (Denial of Service) inside the
CSwitch infrastructure. On the Internet, if a computer receives many data
packets he could be overloaded and as a result, stop being able to provide
service.  On the CSwitch infrastructure, sending many messages to a remote node
costs credit. In addition, a node that is bombarded with many messages earns
credit. 


## Ability to send funds implies ability to send messages

Consider this abstract idea: The abilities to send funds between nodes is
related to the ability to send messages between nodes. 

In particular, if we have a network where sending funds between nodes could be
performed efficiently, it is possible to create a mechanism to send messages
efficiently between nodes. This could be done as follows:

To send a message bit from node `A` to node `B`, `A` could send a `B` 1 credit
to represent the bit `0`, and 2 credits to represent the bit `1`. This
mechanism should also allow `B` to send messages to `A`. If `A` and `B` send
about the same amount of bytes to each other, on average none of them should
ever run out of funds to be able to send communication.

This of course is a very abstract idea, but it shows that ability to send funds
implies ability to send messages. 


## Blockchain solutions for passing value are not efficient

The CSwitch infrastrucure allows every node to send a message to a remote node
for a small fee. One could suggest to use a blockchain system, like Bitcoin, to
manage the transfer of funds between nodes (Those funds are the payment for
sending messages).

Direct blockchain based payment for every message sending is very inefficient,
as a blockchain based transaction involves communication to the whole
participants of the network.

One could suggest instead that nodes remember the debt between them, and settle
the payment at a later time using a blockchain based transaction. In the next
sections we take this idea further, and remove the requirement for a blockchain
based transaction to settle the debt.


## Mutual credit clearing

Assume that two business owners, a milkman and a baker, live next to each
other. Also assume that they live in a world without money.

One way the milkman and the baker could exchange goods without the use of money
is using the method of barter. the milkman could ask the baker from some break,
in exchange for some milk.  However, what if at a specific time the milkman
wants to get some bread from the baker, but the baker doesn't need any milk
from the milkman? In this case, the method of barter will not allow to perform
a transaction. Barter only works if the two involved parties are interested in
the exchange in a specific point in time and location.

To solve the problem, the milkman and the baker could use **mutual credit
clearing**: If the milkman wants to get bread from the baker, but the baker
doesn't need any milk right now, the baker will give the milkman a loaf of
bread, and write down on a piece of paper that the milkman owes him some
credit. The milkman will also write a similar note for reference.

A few days later later, if the baker wants to get milk from the milkman, but
the milkman doesn't want any bread from the baker at that specific point of
time, the baker could use his credit at the milkman to get milk. After the
milkman gives the baker a bottle of milk, the debt of the milkman to the baker
is cleared.

This method allows the milkman and the baker to perform exchange of their
goods, even if they do not want to exchange them at exactly the same time. 

One assumption that mutual credit clearing makes is that the milkman and the
baker trust each other. Suppose that the milkman takes 5 loafs of bread from
the baker. The milkman and the baker both write a note that the milkman ows the
baker credit that equals 5 loafs of bread. What if the milkman is gone one day,
without ever repaying the debt to the baker? The baker is left with a note that
the milkman ows him credit, but this note can not be redeemed anywhere for
goods.

The baker, by allowing the milkman to have debt to him, trusts that the milkman
will stick around to be able to pay back the debt in the future, in some way.

Some measures to be taken when using mutual credit clearing:

- Mutual credit clearing should only be set up between people that trust each
    other. It is advantage if those people know each other from the real world,
    and they have met in person.

- The maximum debt possible in the mutual credit clearing between two sides
    should be limited to some maximum amount. For example: If the baker allows the milkman to owe
    him credit of value at most 3 loafs of bread, the baker will not be able to lose
    more than 3 loafs of bread if A can't repay the debt.


Given these assumptions, the state of mutual credit between two nodes A and B
consists of the following parameters:

- A allows B maximum debt of md{AB}
- B allows A maximum debt of md{BA}

md{BA} and md{AB} are not necessarily equal. Drawn on a one dimensional scale,
we get a picture as follows (from the point of view of A):

```
                     d{AB}
     [-----------|-----^-------]
  -md{BA}        0           md{AB}
```

In the picture, B owes A some amount of money. The `^` marks shows the current
credit relationship between A and B. The value d{AB} is the mutual credit state
between A and B. It denotes the purchasing power of A with respect to B. It is
always true that `-md{BA} <= d{AB} <= md{AB}`. Note the symmetric property:
`d{AB} = -d{BA}`.

From the point of view of B, the picture looks as follows:

```
            d{BA)
     [-------^-----|-----------]
  -md{AB}          0         md{BA}
```

In the CSwitch architecture, we call such a pair of identities A and B **friends**.
A pair of friends represents a trust relationship in the real world between two
people.

The economy of mutual credit clearing between two people is simple, and it
requires that each side generates goods that the other side wants. In the
example above, the milkman wants to get bread, and the baker wants to get milk.
This does not always happen in the real world. 

If, for example, the baker decided to stop drinking milk (Maybe he got
allergic?), the simple mutual credit clearing between the milkman and the baker
will not keep working. After a few loafs of bread that the milkman takes from
the baker for credit, the baker will not allow the milkman to take any more,
because the debt is too large.

This problem could be solved if the baker possibly wanted to buy service from
the carpenter, assuming that the carpenter buys milk from the milkman. This
will usually happen in an economy of multiple players.


## Chains of mutual credit clearing

To extend the idea of credit clearing to the economy of multiple players we use
chains of mutual credit clearing. In this setting, every person has a few other
people he trusts, and maintains mutual credit clearing with.

Assume that a person A wants to send funds to another person B. If A and B
are friends (They directly manage mutual credit clearing), the transaction is
simple: A will decrease d{AB} and B will increase d{BA}. 

If A and B are not friends, they need the help of a mediator, or a chain of
mediators, to perform the transaction. A and B will look for a chain of the
following form:

```
A -- M1 -- M2 -- M3 -- B
```

Where A, M1 are friends, M1, M2 are friends, M2, M3 are friends and M3, B are
friends. Of course, the length of the chain could be arbitrary.

To transfer funds from A to B, A will first transfer funds to M1, M1 and will
transfer the funds to M2, M2 will transfer the funds to M3 and M3 will transfer
the funds to B. Each mediator (M1, M2, M3) can take a little amount of funds
for himself during the transaction, in exchange for helping A and B perform the
transaction.

We assume that friendship between people in the real world should allow any two
strangers A,B to find a chain of friends that connects them, to allow transfer
of funds between A and B. If no such chain is found, transfer of funds will not
be possible.


## Buying communication for credit

We showed above how funds could be transferred between nodes that are not
friends (They do not have a direct mutual credit clearing setup). We could use
a similar idea for the transfer of communication between nodes.

Assume of network of nodes, where every node is directly connected to some other
predefined nodes. If A and B are two directly connected nodes, we say that A
and B are **neighbors**. 

Note that being neighbors is not the same as being friends. Being neighbors
means being adjacent in the network topology. It does not imply the trust
required for being friends. Hence the network of neighbors (Used for transfer
of communication) is independent of the network of friends (Used for the
transfer of funds).

If A wants to send a message to some remote node C, A first finds a path from A
to C that goes along neighbors. For example:

```
A -- N1 -- N2 -- C
```

In the picture, A and N1 are neighbors, N1 and N2 are neighbors and N2 and C
are neighbors. This means that there is a direct communication channel from A
to N1, from N1 to N2 and from N2 to C. We will pass the message from A to C
along this path of neighbors.

To send the message, A prepares a message together with payment to the
mediators N1, N2, and to the recipient C. The mediators will pass the message
and earn some amount of credit for their services.


How can A pay N1? A and N1 maintain mutual credit clearing with very small
maximum debt amounts. 

There is no real world relationship between A and N1, hence they can not trust
each other to repay large debts. However, A and B can set up mutual credit
clearing for very small amounts.

Generally this setup of small mutual credit clearing should be sustainable if A
and B send similar amounts of messages through each other. However, if for
example A sends many messages through B and reaches the maximum debt B allows,
A will send B funds using a chain of friends from A to B. 

The mutual credit between two neighbors represents communication purchasing
power. If A and B are neighbors, A will try to ensure that it is not too close to
the maximum debt possible to B, and B will try to ensure it is not too close to
the maximum debt possible to A.

If for example, A notices that it is getting close to the maximum debt possible
to B, it will send funds to B through a chain of friends. The funds should be
approximately enough to balance the mutual credit between the neighbors A
and B.

As a summary: large amounts of credit passes using chain of friends, and
neighbors maintain mutual credit for very small amounts, used mostly for the
purchase of communication ability.


## Backwards credit payment

In the previous sections we showed that transfer of funds between
two nodes could be accomplished by "pushing" credit along a chain of friends.
On the communication layer, we showed that communication between two nodes is
done by sending messages together with credit along a chain of neighbors.

To examine the security of this setup, we need to consider the incentives of
the nodes participating in the transaction. In this section we introduce a
method to perform a transaction in the communication layer, between neighbors.
The considerations for a transaction done in the funds layer (between friends)
should be similar.

Consider the following network formation of neighbors:

```
A -- B -- C -- D
```

A,B are neighbors, B,C are neighbors, C,D are neighbours. Suppose that A wants
to send a message to D. We described earlier the general idea for sending a
message from A to B together with payments to the mediators, but we didn't yet
gave the specifics of how to do this, to make this transaction somewhat atomic
and secure.

Consider first the following naive idea: A will calculate how much credit he
needs to give to each of the mediator, for example: 2 credits to B, 2 credits
to C and 2 credits to D. Next, A will send prepare the message together with
payments of 6 to B, requesting to pass the message all the way to A.

B could keep 2 credits to himself, passing the message with 4 credits to C.
However, it is of greater benefit to B to keep the 6 credits to himself and
discard the message. 

We solve this problem using the idea of backwards payment of credits. This idea
is crucial to the operation of CSwitch.

When A sends a message to B, instead of sending the message together with
credit, it sends the message to B together with a promise for credit, in the
future, if the message is delivered. A promises to pay B 6 credits if he brings
back proof that the message was delivered to D.

Next, B passes the message to C, together with a promise to pay 4 credits if C
brings a proof that the message was delivered to D. C sends the message to D,
together with a promise to pay 2 credits if D signs the message and sends the
signature back to C.

D receives the message, creates a signature of receipt, and sends it back to C.
C pays 2 credits to D. Next, C sends the signature back to B and receives 4
credits from B. B Finally B sends the signature back to A and receives 6
credits.

Eventually, A paid 6 credits, and B,C,D each earned two credits. In addition, A
knows that the message was received by D. 

We distinguish between two stages in this transaction: We call the forward
stage (Sending the message from A to D) the request, and the backwards stage
(Sending the signature from D to A) the response.

What happens if one of the mediators can not pass the message during the
request stage? For example, if C wants to pass the message to D, but the cable
between C and D suddenly disconnected? C will send back a message to B,
claiming that the message could not be delivered, together with C's signature.
B will pay C 1 credit.  B will then forward this error message to A. Seeing the
provided error message, A will pay B 2 credits. 

In the case of such error, every node in the path up to the problem location
will receive only half of the originally promised credit amount.

The example above does not take into account the length of the transferred
message. The longer the message, the more effort the mediators need to do to
pass the message, and the more they should be paid.

In CSwitch the typical payment for passing a message is `2 * len(message)`
credit. We multiply by `2` to allow for the case of failure, where only half of
the promised amount of credits will be paid.


## Analyzing incentives in Backwards credit payment

We now analyze various cases of action during a backwards credit payment
transaction, to make sure that all the participants of the transaction are
properly incentivized to play by the rules.

Consider the following network formation between neighbors:

```
A -- B -- C -- D -- E
```

The following are some edge cases we manage to deal with:

(1) A sends a message to a nonexistent remote node T.

As a result, One of the nodes, for example D, will send back an error response
message, signed by D, back to C. The error response message will eventually
arrive A, and all the mediator nodes will be paid half of the promised credit
amount. This means that sending a message to a nonexistent remote node costs
money to A, and the mediator nodes are still compensated.


(2) B receives a request to forward a message to C, but he doesn't forward the
message to C.

This is not a reasonable for B, because B could potentially earn money
from this transaction.


(3) A and E cooperate. When E receives a request message, E doesn't return a
signed response message to D.

D will keep the transaction open, waiting for a response from E. This blocks
the channel between D and E. Next time, A will not be able to send a message to
A through D. The channel between D and E will be opened only when E sends back
a response message to D.


(4) B receives a response message from C but doesn't pay C.

An inconsistency will be created in the neighbor relationship between B and C,
and communication will not continue between them until this inconsistency is
solved manually.


(5) C receives a response message from D but does not pass it to B.

This means that C gives up on credit, passing the response message to B will
earn C credit. Therefore, C will prefer to pass the response message to B.


Analyzing the cases above does not mean that the backwards credit payment is
proved to be safe, but currently we do not know of any holes in its design.



TODO: Write about possible infinite delay of a transaction, partial solution.



## Distributed routing is difficult

To be able to send messages in the graph of neighbors or to send funds in the
graph of friends, we need to be able to find paths between nodes.

Finding paths between nodes in a distributed setting (Every node only knows his
immediate graph neighbors) is a difficult problem. We never managed to find a
solution to this problem that is both distributed and efficient. Currently we
do not know of any method of distributed routing that scales well.

The naive solution for this problem is flooding: Every node passes the message
to all the nodes that he knows of, until the message arrives at all nodes.
Specifically, the message also arrives at its destination.

The method of flooding is very inefficient, and can not be used in CSwitch, as
CSwitch should be an efficient communication infrastructure.

Other methods were tested as part of the freedomlayer project. Those attempts
are outside of the scope of this document, and can be read at the 
[Freedomlayer research section](https://www.freedomlayer.org/pages/research.html).


## Using centralized indexers

Instead of using distributed routing, we plan to use centralized, possibly
federated, set of index nodes. Those nodes will run different code from the
rest of the node on the network, and will supply the service of finding paths
in the networks of neighbors and friends. This service will be provided in
exchange for credit.

Every node in the network should maintain at all times paths to a few closest
indexer nodes. Those paths are exchanged using gossip between neighbors in the
network. The indexer nodes will have identity signed by an official key, so
that all nodes in the network will be able to recognize them.

Every node sends periodically to the a few close indexers the following
information:

- A of current neighbors 
- A set of current friends, and current funds capacities to those friends (How
    much funds could be pushed to each friend)
- A current communication public key, that could be used for a fast half-static
    diffie-hellman exchange with another node. (TODO: Should we have this?)

When this information is received by an indexer, it will be propagated to the
rest of the indexers somehow. The communication between the indexers could be
done over the CSwitch infrastructure, which means that the indexers themselves
need to pay for communication.

If we let different nonrelated people run indexers themselves, we run the risk
of no cooperation between them. It is possible that person Q that runs an
indexer will not propagate network topology changes to person T that runs an
indexer. If this happens, T will not have an updated view of the network.

This problem of incentives between indexer operators is currently unsolved, and
therefore the current plan is to let us own all indexers with an official
public key.


Whenever a node A wants to send a message to some remote node B, A will first
send a request for route to B to one (or more) of the closest indexers he knows
of. A will then receive a few possible routes to B. Using these routes, A will
be able to send a message to B. (The response will possibly include a recent
communication public key of B. This will allow A to perform a static
diffie-hellman exchange with B, saving one roundtrip time).

The request that A sends to an indexer I goes over the communication layer,
between neighbors. It contains extra credit for:

- Processing of the path finding.
- Allocating bytes for the indexer response.

These types of extra credit inside communication messages (processing fee, fee
for response bytes allocation) are part of the specification for a message in
the communication layer between friends, and could be used for other purposes
by users of the CSwitch infrastructure.


An indexer node works as a node over the CSwitch infrastructure. 

TODO: Write about how one indexer works.


The indexers part of the design is the part we are worried about the most,
because it is not decentralized, and not even federated. We will be happy to
change this design to something more decentralized, if a solution is found.



TODO: Write about finding credit flow using indexers.
