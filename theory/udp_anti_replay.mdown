# UDP style anti-replay
23.01.2018


## Introduction

Many encryption schemes rely on an underlying communication layer that
guarantees the order of sent messages. This underlying communication layer is
usually TCP. Examples for such encryption schemes are SSH and TLS. Such
encryption schemes fail to work over a communication layer that does not
guarantee ordered arrival of messages.

Consider SSH for example: In order to avoid replay attacks, SSH uses an
incrementing counter for each side of the communication. Every messages
contains an internal counter that increments for every message. The receiving
side always checks the internal counter of incoming messages. If the counter
value does not match the expected value, the message is discarded.

Consider a UDP like communication layer between two parties A and B, where there
is no guarantee for ordered arrival of messages: Messages may be dropped or
arrive out of order. We want to set up an encrypted channel over such a
communication layer.

In this case we can not use the countermeasure used by SSH to defend against
replay attacks. We can not use an incrementing counter because we can not be
sure that messages arrive at the remote party at the same order they were sent.

This document presents a design for an anti-replay mechanism to be used when
encrypting UDP style communication layers. Idea is due to Zur, and thus called
Zur's sliding window.


## Problem setup

Consider two parties A and B sending datagrams over a nonreliable UDP style
communication layer. Assume that A and B have a symmetric key for encryption
from A to B, and a symmetric key for encryption from B to A. We also assume
that the encryption scheme used by A and B also provides authenticity. This
means that when B receives an encrypted message from A, he knows for sure that
only A could have generated this message.

An attacker E can see all the communication on the wire between A and B, and
can send messages on the wire. E does not know the symmetric keys for encrypted
communication between A and B.

```
A -----+------- B
       |
       |
       |
       E 
```

If A naively sends encrypted datagrams to B, E will be able to resend those
datagrams to B, making B think that A have sent those messages again. We call
this attack **replay attack**. 

Why is this a security problem? Consider this example: A sends a message to
open a gate, a person then enters a building, and finally A sends a message to
close the gate.  If E could replay the "open gate" message, E could enter the
building. 

A and B need to find a way to send encrypted datagrams so that E will not be
able to replay those messages.

## Maintaining counters

We define two plaintext messages that could be sent between parties in the
network:

**RequestCounter**

- nodeId


**ResponseCounter**

- nodeId
- prefix         [64 bits]
- currentCounter [64 bits]

(Note: RequestCounter message allows any user to "impersonate" to any other user
by specifing a certain nodeId. We claim that even in this setting our
encryption scheme is secure.)

Every party P may send a RequestCounter message to B and receive a
ResponseCounter message containing the corresponding currentCounter for the
specified nodeId.

The party B keeps a state (with a counter) for every party it comes in contact
with. This state is erased if no action (related to this state) happens for a
very long time. 

If B maintains no state for some nodeId K, and a RequestCounter message with
nodeId=K is received, B generates a new state for K containing a random
currentCounter, and responds with a ResponseCounter message containing the
newly generated currentCounter..

If A wants to send a message to B, A needs to know the currentCounter[A] B keeps
for receiving messages from A. 

1. A sends a RequestCounter(nodeId=A) message to B.
2. B sends a ResponseCounter(nodeId=A) message to A, containing currentCounter[A].

After this exchange, A can send an encrypted datagram, where the contents of
the datagram are of the form:


**PlainMessage**

- prefix
- currentCounter
- data


If A wants to send another message, A will increment the counter and send
another encrypted PlainMessage to B. 

In the case of ordered communication between A and B (Messages arrive at the
same order they were sent), B may maintain the currentCounter and increase it
every time a message is received from A, thus keeping A's and B's counters in
sync. However, in our setting we consider a communication layer where messages
may not arrive, or arrive out of order. 


## Zur's sliding window

We want to avoid replay attacks, but still over a non reliable UDP like
communication layer. To do this, B has to maintain a bit more state than a
single counter.

For every nodeId that was ever received in a RequestCounter message, B will
maintain the following state:


**ZurState[nodeId]**

- prefix         [64 bits]
- currentCounter [64 bits]
- bitmask        [256 bits]


currentCounter is the same currentCounter that was sent in the ResponseCounter
message. bitmask contains bits representing the arrival of recent messages.

We count bits inside bitmask starting from 0 as the least significat bit.
Bit number i represents whether the message with counter value `currentCounter
- i - 1` was ever received. `0` means no, `1` means yes. 

Whenever an encrypted PlainMessage is received from A, B does the following:

1. Decrypts the message (At the same time: 
    makes sure that it was encrypted by A). If the message is invalid or not
    encrypted by A, it is discarded.
2. Checks if the prefix matches A's state prefix. If not, discard the message.
3. Check the counter:
    3.1 If counter is bigger than currentCounter:
        - Update currentCounter = counter.
        - Shift bitmask counter bits to the left (Inserting the bit `1` from the
            right on the first bit shift).
    3.2 If counter is in [currentCounter - bitmask.len(), currentCounter) and
        the corresponding bitmask bit is 0:
        - Set the bit to 1.
    3.3 Else: Discard the message.


(TODO: Add an example of shifting a bitmask)


## Exhausting currentCounter

TODO: Double state maintanence?


## Setting up a connection in Channeler

(TODO: Move this section somewhere else later)
NOTICE: WORK IN PROGRESS

We consider two sides: client (A) and server (B). The client knows the IP address of
the server, but the server does not know the IP address of the client.

Setting up an encrypted connection:

1. A -> B: Handshake1 (randNonce1, publicKeyA, dhPublicKeyA, keySaltA) 
2. B -> A: Handshake2 (hashPrev, randNonce2, publicKeyB, dhPublicKeyB, keySaltB, Signature(B))
3. A -> B: Handshake3 (hashPrev, Signature(A))


<!--
1. A -> B: Handshake1 (randNonce1, publicKeyA) 
2. B -> A: Handshake2 (hashPrev, randNonce2, publicKeyB, Signature(B))
3. A -> B: Handshake3 (hashPrev, randNonce3, dhPublicKeyA, keySaltA, signature(A))
4. B -> A: Handshake4 (hashPrev, randNonce4, dhPublicKeyB, keySaltB, signature(B))
5. A -> B: Handshake5 (hashPrev, signature(A))
-->


Where:

- hashPrev is sha512/256 over the previous message. This makes sure that the
    messages are ordered correctly.
- signature(X) means a signature over all the previous fields in the message by party X.

A considers the connection to be completed once message Handshake3 is sent. B
considers the connection to be completed once message Handshake3 is received. The
unique name of the connection is the value hashPrev of message Handshake3.

After the connection was set up, each party has two ends of channels, one
sending end and one receving end. The channel from A to B is called
`channelA := hash(dhPublicKeyA || Handshake3.hashPrev)`. The Channel from B to A is called
`channelB := hash(dhPublicKeyB || Handshake3.hashPrev)`.

Both parties A and B create two symmetric keys for sending and receiving
messages (keySaltA is used for sending messages from A to B, keySaltB is used
for sending messages from B to A). We denote the symmetric keys by
symmetricKeyAB (Sending from A to B) and symmetricKeyBA (Sending from B to A).

Each party may maintain at most 2 receiving ends of channels from a given
remote party. For example, A may maintain at most 2 receiving ends for channels
from B. Whenever a new receiving end is created, it replaces the oldest
receiving end from the list of receiving ends of A from B. 

This makes sure that when a new channel is opened from B to A, if there are
still some messages from B to A on the previous channel floating in the
network, A will be able to receive those messages when they arrive. Those
messages will be received on the previous channel receiver.

A sets up a receiving state for channelB, including a sliding Zur window. It
also sets up a sending state for channelA, containing a counter. The counter
begins from 1.

An encrypted message from A to B has the following format:

**EncryptedMessage**

- channelName
- Enc[symmetricKeyAB]{plain}

Where plain is of the form:

- channelName
- counter
- data


Each side of transmittion (A -> B or B -> A) has a separate counter that begins
from 0. 


## Channeler Connection teardown

It is possible that one of the sides malfunctions or restarts. In that case the
state of the channel will be erased. In that case upon a receipt of
EncryptedMessage message, the party will respond with an UnknownChannel
message:


**UnknownChannel**

- channelName
- Signature(channelName)


This will indicate to the other party that the channel can no longer be used for
sending messages, and the sending part of the channel will be removed.
