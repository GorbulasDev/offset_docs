# The design of the AppManager component
17.07.2018

## Intro

The AppManager component is the communication interface between CSwitch and the
user's applications. Most users will not interface with the AppManager
directly. They will instead use an application that wraps CSwitch
functionality.


```

   +----[CSwitch]----+
   |                 |      +--------------+
   |     Networker --+------|              |========== IndexerClient
   |                 |      |  AppManager  |
   |     Funder -----+------|              |---------\
   |                 |      +--------------+         +---- App
   |      ...        |                               +---- App
   +-----------------+                               +---- App

```

User's applications are native programs running on the user's machine (Or
possibly outside of it, communicating securely with the AppManager). They
could be implemented by anyone, in any language. The communication between
user's apps and the AppManager is done over secure TCP connection.

AppManager exposes low level API for the main CSwitch abilities:
Sending and receiving messages and funds and the management of trust for
neighbors and friends. 

The AppManager is also the connection point between CSwitch and an
IndexerClient. IndexerClient is a "special" app that provides CSwitch with
routes between neighbors and friends. An operational IndexerClient is crucial
for the operation of the CSwitch engine.

We say that IndexerClient is a "special" app because it has a different
interface to AppManager than the rest of the apps have. IndexerClient is the
only app that has the ability to receive requests (for routes) from the CSwitch
engine.

Examples for possible apps to be connected to AppManager:

- A driver that provides the user with an IPv6 interface (Like done on [CJDNS](https://github.com/cjdelisle/cjdns)).
- A graphical web interface for managing trust between neighbors and friends.
- An app for automatic payment.


## Configuration

On startup, the AppManager should load a configuration file. The configuration
file should contain: 

- IndexerClient configuration:
    - The public key of IndexerClient app.

- Apps configuration:
    - App name (TODO: What if there are multiple instances of the same application?)
    - App public key
    - App permissions


The configuration should be some textual format, possibly [TOML](https://github.com/toml-lang/toml).

Other information (Like neighbors list, friends list and their state) will be
obtained as messages from the Networker and Funder.


## Security

The AppManager is the gatekeeper to the CSwitch engine. CSwitch serves as a
user's wallet, and therefore it must be secured. Restricting access to CSwitch
through the AppManager component is done using the following mechanisms:

- Application public keys whitelist
- Application permissions


## Secure communication

The communication between AppManager and an app begins as follows:

(0) Application opens a TCP connection to AppManager.

(1) Application -> AppManager:

[AppRandNonce]
- appRandNonce
- appPublicKey

(if appPublicKey is not on the AppManager's whitelist, he will close the
connection).

(2) AppManager -> Application:

[AppManagerRandNonce]
- appManagerRandNonce
- appManagerPublicKey

(if appManagerPublicKey is not as expected for the app, the app will close the
connection).

(3) Application -> AppManager:

[AppDh]
- appDhPublicKey
- appManagerRandNonce
- appKeySalt
- signature{appPublicKey}(previous fields)

(if the signature is invalid, the connection will be closed).

(4) AppManager -> Application:

[AppManagerDh]
- appManagerDhPublicKey
- appManagerRandNonce
- appManagerKeySalt
- signature{appManagerPublicKey}(previous fields)

(if the signature is invalid, the connection will be closed).


TODO: Handle possible man in the middle attack with curve25519 (Weak points in
the group).

After the exchange, both the Application and the AppManager combine the dh keys
into one shared secret. This shared secret is then expanded into two symmetric
keys for communication, a key for each direction. (A key for AppManager -> App,
and another key for App -> AppManager). 

The derivation of two symmetric keys is done using the
[hkdf](https://en.wikipedia.org/wiki/HKDF) algorithm. See the function
`derive_symmetric_key()` at `src/ccrypto/dh.rs` for more details.

Symmetric encryption will be done using ChaCha20 with Poly1305 for
authentication. Nonces will be generated randomly. See for example
Encryptor::encrypt() method at `src/crypto/sym_encrypt.rs` for more details.


## Interface with IndexerClient

(Will be serialized using capnp)

[RequestSendMessage]            IndexerClient -> AppManager
- requestId
- neighborsRoute
- requestContent
- maxResponseLen
- processingFeeProposal

[ResponseSendMessage]           AppManager -> IndexerClient
- requestId
- processingFeeCollected
- responseContent

[MessageReceived]               IndexerClient -> AppManager
- requestId
- neighborsRoute
- requestContent
- maxResponseLen
- processingFeeProposal

[RespondIncomingMessage]        AppManager -> IndexerClient
- requestId
- processingFeeCollected
- responseContent

[RequestNeighborsRoute]         AppManager -> IndexerClient
- sourceNodePublicKey
- destNodePublicKey

[ResponseNeighborsRoute]        IndexerClient -> AppManager
- List(NeighborsRoute)

[RequestFriendsRoute]           AppManager -> IndexerClient
- one of:
    - Direct
        - sourceNodePublicKey
        - destinationNodePublicKey
    - LoopFromFriend 
        - friendPublicKey
    - LoopToFriend
        - friendPublicKey


[ResponseFriendsRoute]          IndexerClient -> AppManager
- routes:
    - capacity
    - FriendsRoute


Where NeighborsRoute is defined as follows: (See `src/networker/messenger/types.rs`):

```rust
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NeighborRouteLink {
    pub node_public_key: PublicKey,
    pub payment_proposal_pair: PaymentProposalPair,
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct NeighborsRoute {
    pub (super) source_public_key: PublicKey,
    pub (super) source_request_proposal: NetworkerSendPrice,
    pub (super) route_links: Vec<NeighborRouteLink>,
    pub (super) dest_public_key: PublicKey,
    pub (super) dest_response_proposal: NetworkerSendPrice,
}
```

TODO: FriendsRoute will be defined similarly, with larger (u128) sizes for the
payment proposal structures.


## Interface with an Application

(Will be serialized using capnp)

Messages:

```
RequestSendMessage            Application -> AppManager
ResponseSendMessage           AppManager -> Application
MessageReceived               AppManager -> Application
RespondIncomingMessage        Application -> AppManager
```

Funds transfer:

```
RequestSendFunds              Application -> AppManager
ResponseSendFunds             AppManager -> Application
ReceiptAck                    Application -> AppManager
```


Neighbor management:

```
OpenNeighbor                  Application -> AppManager
CloseNeighbor                 Application -> AppManager
AddNeighbor                   Application -> AppManager
RemoveNeighbor                Application -> AppManager
EnableNeighbor                Application -> AppManager
DisableNeighbor               Application -> AppManager

SetNeighborRemoteMaxDebt      Application -> AppManager
SetNeighborMaxTokenChannels   Application -> AppManager

NeighborStateUpdate           AppManager -> Application
ResetNeighborChannel          Application -> AppManager
```


Friend management:

```
OpenFriend                    Application -> AppManager
CloseFriend                   Application -> AppManager
AddFriend                     Application -> AppManager
RemoveFriend                  Application -> AppManager
EnableFriend                  Application -> AppManager
DisableFriend                 Application -> AppManager

SetFriendRemoteMaxDebt        Application -> AppManager

FriendStateUpdate             AppManager -> Application
ResetFriendChannel            Application -> AppManager
```


Routes:

```
RequestNeighborsRoute         Application -> AppManager
ResponseNeighborsRoute        AppManager -> Application
RequestFriendsRoute           Application -> AppManager
ResponseFriendsRoute          AppManager -> Application
```


## Interface with Networker

```
RequestSendMessage            AppManager -> Networker
ResponseSendMessage           Networker -> AppManager
MessageReceived               Networker -> AppManager
RespondIncomingMessage        AppManager -> Networker

OpenNeighbor                  AppManager -> Networker
CloseNeighbor                 AppManager -> Networker

RequestNeighborsRoute         Networker -> AppManager
ResponseNeighborsRoute        AppManager -> Networker

SetNeighborRemoteMaxDebt      AppManager -> Networker
SetNeighborMaxTokenChannels   AppManager -> Networker

OpenNeighbor                  AppManager -> Networker
CloseNeighbor                 AppManager -> Networker
AddNeighbor                   AppManager -> Networker
RemoveNeighbor                AppManager -> Networker
EnableNeighbor                AppManager -> Networker
DisableNeighbor               AppManager -> Networker

NeighborStateUpdate           Networker -> AppManager
ResetNeighborChannel          AppManager -> Networker
```


## Interface with Funder

```
RequestSendFunds              AppManager -> Funder
ResponseSendFunds             Funder -> Application
ReceiptAck                    AppManager -> Funder

RequestFriendsRoute           Funder -> AppManager
ResponseFriendsRoute          AppManager -> Funder

OpenFriend                    AppManager -> Funder
CloseFriend                   AppManager -> Funder
AddFriend                     AppManager -> Funder
RemoveFriend                  AppManager -> Funder
EnableFriend                  AppManager -> Funder
DisableFriend                 AppManager -> Funder

SetFriendRemoteMaxDebt        AppManager -> Funder

FriendStateUpdate             Funder -> AppManager
ResetFriendChannel            AppManager -> Funder
```



# TODO:

- Add a basic implementation for structs: 
    - In capnp schema (For communication with Apps and IndexerClient)
    - As Rust structs for communication with Networker and Funder.
 
- Explain logic behind messages: What should the AppManager do when a message
    is received? How to redirect etc.

- What should AppManager do when any of the following happens:
    - An App disconnects.
    - The IndexerClient disconnects.

- How to keep funder receipts.


