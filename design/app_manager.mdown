# The design of the AppManager component
17.07.2018

## Intro

The AppManager component is the communication interface between CSwitch and the
user's applications. Most users will not interface with the AppManager
directly. They will instead use an application that wraps CSwitch
functionality.


```

   +----[CSwitch]----+
   |                 |      +--------------+
   |     Networker --+------|              |========== IndexerClient
   |                 |      |  AppManager  |
   |     Funder -----+------|              |---------\
   |                 |      +--------------+         +---- App
   |      ...        |                               +---- App
   +-----------------+                               +---- App

```

User's applications are native programs running on the user's machine (Or
possibly outside of it, communicating securely with the AppManager). They
could be implemented by anyone, in any language. The communication between
user's apps and the AppManager is done over secure TCP connection.

AppManager exposes low level API for the main CSwitch abilities:
Sending and receiving messages and funds and the management of trust for
neighbors and friends. 

The AppManager is also the connection point between CSwitch and an
IndexerClient. IndexerClient is a "special" app that provides CSwitch with
routes between neighbors and friends. An operational IndexerClient is crucial
for the operation of the CSwitch engine.

We say that IndexerClient is a "special" app because it has a different
interface to AppManager than the rest of the apps have. IndexerClient is the
only app that has the ability to receive requests (for routes) from the CSwitch
engine.

Examples for possible apps to be connected to AppManager:

- A driver that provides the user with an IPv6 interface (Like done on [CJDNS](https://github.com/cjdelisle/cjdns)).
- A graphical web interface for managing trust between neighbors and friends.
- An app for automatic payment.


## Configuration

On startup, the AppManager should load a configuration file. The configuration
file should contain: 

- IndexerClient configuration:
    - The public key of IndexerClient app.

- Apps configuration:
    - port number (u32). 
    - App name (TODO: What if there are multiple instances of the same application?)
    - App public key
    - App permissions


The port number allow AppManager to forward messages to applications. Remote
nodes can choose a port to decide to send a message to a remote application.
Therefore no two applications can have thee same port.

Possible permissions (From lower to higher):
(TODO: Review the model of permissions. Is this the wanted level of
granularity?)

- VIEW
    - View changes to the state of CSwitch.

- COMMUNICATION
    - View changes to the state of CSwitch.
    - Allows to send and receive communication.

- COMMUNICATION_AND_FUNDS
    - View changes to the state of CSwitch.
    - Allows to send and receive communication.
    - Allows to send funds.

- ALL
    - View changes to the state of CSwitch.
    - Allows to send and receive communication.
    - Allows to send funds.
    - Allows to manage neighbors and friends.

The configuration should be some textual format, possibly [TOML](https://github.com/toml-lang/toml).

Other information (Like neighbors list, friends list and their state) will be
obtained as messages from the Networker and Funder.


## Security

The AppManager is the gatekeeper to the CSwitch engine. CSwitch serves as a
user's wallet, and therefore it must be secured. Restricting access to CSwitch
through the AppManager component is done using the following mechanisms:

- Application public keys whitelist
- Application permissions

(NOTE: At the initial implementation permissions are not required. We can add
this feature in the future.)


## Secure communication

The communication between AppManager and an app begins as follows:

(0) Application opens a TCP connection to AppManager.

(1) Application -> AppManager:

[AppRandNonce]
- appRandNonce
- appPublicKey

(if appPublicKey is not on the AppManager's whitelist, he will close the
connection).

(2) AppManager -> Application:

[AppManagerRandNonce]
- appManagerRandNonce
- appManagerPublicKey

(if appManagerPublicKey is not as expected for the app, the app will close the
connection).

(3) Application -> AppManager:

[AppDh]
- appDhPublicKey
- appManagerRandNonce
- appKeySalt
- signature{appPublicKey}(previous fields)

(if the signature is invalid, the connection will be closed).

(4) AppManager -> Application:

[AppManagerDh]
- appManagerDhPublicKey
- appManagerRandNonce
- appManagerKeySalt
- signature{appManagerPublicKey}(previous fields)

(if the signature is invalid, the connection will be closed).


TODO: Handle possible man in the middle attack with curve25519 (Weak points in
the group).

After the exchange, both the Application and the AppManager combine the dh keys
into one shared secret. This shared secret is then expanded into two symmetric
keys for communication, a key for each direction. (A key for AppManager -> App,
and another key for App -> AppManager). 

The derivation of two symmetric keys is done using the
[hkdf](https://en.wikipedia.org/wiki/HKDF) algorithm. See the function
`derive_symmetric_key()` at `src/ccrypto/dh.rs` for more details.

Symmetric encryption will be done using ChaCha20 with Poly1305 for
authentication. Nonces will be generated randomly. See for example
Encryptor::encrypt() method at `src/crypto/sym_encrypt.rs` for more details.


## Interface with IndexerClient

(Will be serialized using capnp, See app_manager.capnp for more details)

```
RequestPath                   IndexerClient -> AppManager
ResponsePath                  AppManager -> IndexerClient
RequestSendMessage            IndexerClient -> AppManager
ResponseSendMessage           AppManager -> IndexerClient
MessageReceived               IndexerClient -> AppManager
RespondIncomingMessage        AppManager -> IndexerClient

RequestNeighborsRoute         AppManager -> IndexerClient
ResponseNeighborsRoute        IndexerClient -> AppManager

RequestFriendsRoute           AppManager -> IndexerClient
ResponseFriendsRoute          IndexerClient -> AppManager
```

AppManager allows IndexerClient to send and receive messages. This is done by
forwarding those messages to/from the Networker. Examples:

```
           RequestSendMessage             RequestSendMessage
Networker     <----------     AppManager   <--------------   IndexerClient



           ResponseSendMessage            ResponseSendMessage 
Networker     ---------->     AppManager   -------------->   IndexerClient
```

AppManager also forwards requests for routes of both the Networker and the
Funder to IndexerClient. Example:

```
           RequestFriendsRoute            RequestFriendsRoute
Networker     ---------->     AppManager   -------------->   IndexerClient
```

Note that the above is not a mistake. Networker is the one that should be
asking for friends routes, and Funder is the one that should be asking for
neighbors routes.


## Interface with an Application

(Will be serialized using capnp, See app_manager.capnp for more details)

Messages:

```
RequestPath                   Application -> AppManager
ResponsePath                  AppManager -> Application
RequestSendMessage            Application -> AppManager
ResponseSendMessage           AppManager -> Application
MessageReceived               AppManager -> Application
RespondIncomingMessage        Application -> AppManager
```

Funds transfer:

```
RequestSendFunds              Application -> AppManager
ResponseSendFunds             AppManager -> Application
ReceiptAck                    Application -> AppManager
```


Neighbor management:

```
OpenNeighbor                  Application -> AppManager
CloseNeighbor                 Application -> AppManager
AddNeighbor                   Application -> AppManager
RemoveNeighbor                Application -> AppManager
EnableNeighbor                Application -> AppManager
DisableNeighbor               Application -> AppManager

SetNeighborRemoteMaxDebt      Application -> AppManager
SetNeighborMaxTokenChannels   Application -> AppManager

ResetNeighborChannel          Application -> AppManager

NeighborStateUpdate           AppManager -> Application
```


Friend management:

```
OpenFriend                    Application -> AppManager
CloseFriend                   Application -> AppManager
AddFriend                     Application -> AppManager
RemoveFriend                  Application -> AppManager
EnableFriend                  Application -> AppManager
DisableFriend                 Application -> AppManager

SetFriendRemoteMaxDebt        Application -> AppManager

ResetFriendChannel            Application -> AppManager

FriendStateUpdate             AppManager -> Application
```


Routes:

```
RequestNeighborsRoute         Application -> AppManager
ResponseNeighborsRoute        AppManager -> Application
RequestFriendsRoute           Application -> AppManager
ResponseFriendsRoute          AppManager -> Application
```


Messages related to communication messages are forwarded from the Applicaction
to the Networker, and the other way around.
Messages related to Funds transfer are forwarded from the Application to the
Funder, and the other way around.

A ResponseSendFunds message sent from AppManager to the Application should be
kept at the AppManager until a valid receiptAck message is received. 
If a receiptAck have not yet been received, and the Application restarted
(Communication was lost, and then regained), the AppManager should retransmit
the ResponseSendFunds message to the Application.

This is important because ResponseSendFunds contains a receipt for the
payment. If an Application performed a payment and suddenly crashed before
obtaining the receipt, credits could be lost. Using the receiptAck mechanism we
avoid this possibility. Also note that the Funder will also keep the 
ResponseSendFunds message sent to AppManager until a ReceiptAck message is
received from AppManager. The Funder keeps this information inside a persistent
database.

Illustration:


```
    <--[RequestSendFunds]--           <--[RequestSendFunds]--
Funder                     AppManager                    Application


    --[ResponseSendFunds]-->          --[ResponseSendFunds]-->
Funder                     AppManager                    Application


        <--[ReceiptAck]--               <--[ReceiptAck]--
Funder                     AppManager                    Application

```

On the last step in the illustration, AppManager first receives ReceiptAck,
checks that it is valid, and only then removes the record of the corresponding
ResponseSendFunds message. Funder does the same.

Note that AppManager does not keep any persistent data.


Neighbor management messages are forwarded from the Application to the
Networker. Friends management messages are forwarded from the Application to
the Funder.

NetworkerStateUpdate and FriendsStateUpdate are of special importance.
Whenever a significant change happens for the state of the Networker, the
Networker sends a NetworkerStateUpdate message to AppManager. The same is true
for the Funder.

AppManager should maintain the current state of the Networker and the Funder.
Whenever a new Application connects, AppManager will send it the full state of
the Networker and the Funder using NetworkerStateUpdate and FunderStateUpdate
messages.

In addition, whenever a new {Networker, Funder}StateUpdate messages is
received by the AppManager, the AppManager will forward this message to all
active Applications. This should allow all the Applications to stay up to date
with the current state of the Networker and the Funder.



## Interface with Networker

```
RequestPath                   AppManager -> Networker
ResponsePath                  Networker -> AppManager
RequestSendMessage            AppManager -> Networker
ResponseSendMessage           Networker -> AppManager
MessageReceived               Networker -> AppManager
RespondIncomingMessage        AppManager -> Networker

OpenNeighbor                  AppManager -> Networker
CloseNeighbor                 AppManager -> Networker

RequestFriendsRoute           Networker -> AppManager
ResponseFriendsRoute          AppManager -> Networker

SetNeighborRemoteMaxDebt      AppManager -> Networker
SetNeighborMaxTokenChannels   AppManager -> Networker

OpenNeighbor                  AppManager -> Networker
CloseNeighbor                 AppManager -> Networker
AddNeighbor                   AppManager -> Networker
RemoveNeighbor                AppManager -> Networker
EnableNeighbor                AppManager -> Networker
DisableNeighbor               AppManager -> Networker

NeighborStateUpdate           Networker -> AppManager
ResetNeighborChannel          AppManager -> Networker
```


## Interface with Funder

```
RequestSendFunds              AppManager -> Funder
ResponseSendFunds             Funder -> Application
ReceiptAck                    AppManager -> Funder

RequestNeighborsRoute         Funder -> AppManager
ResponseNeighborsRoute        AppManager -> Funder

OpenFriend                    AppManager -> Funder
CloseFriend                   AppManager -> Funder
AddFriend                     AppManager -> Funder
RemoveFriend                  AppManager -> Funder
EnableFriend                  AppManager -> Funder
DisableFriend                 AppManager -> Funder

SetFriendRemoteMaxDebt        AppManager -> Funder

ResetFriendChannel            AppManager -> Funder
FriendStateUpdate             Funder -> AppManager
```


## Behaviour on special cases

**An Application disconnects**

All unacknowledged ResponseSendFunds messages will be kept, in case the
Application reconnects later.

TODO: What should be done in the following cases:

- IndexerClient disconnects.
- Timeout when asking for a route from IndexerClient.


TODO:

- Explain about random generation of paymentId and messageId used for
    communication with the AppManager.

