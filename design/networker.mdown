# Networker design

10.12.2017
Required prior reading: 0_credit_clearing.mdown


## Introduction

The Networker component is the interface used by all other components for
sending and receiving messages in the CSwitch network. In addition, it is
responsible for mutual credit management against the Networkers of the
node's neighbors.

The Networker is the core component of the CSwitch client. It performs the
"magic" that allows secure exchange of communication and credit.


## Introduction to Token Channels

Consider the Networkers of two neighbor nodes A and B. A and B manage mutual
credit. A sends a few messages, some of which should increase A's balance with
respect to B. At the same time B sends a few message, some of which should
increase B's balance with respect to A.

If any of A or B crash in the middle of the messages transfer, it can become
difficult to find out what is the current credit balance between A and B,
which messages were received by any of the parties, and possibly which messages
need to be resent.

We choose the following conservative solution: At each given time only one of
the nodes A and B is allowed to send a message. In other words: A and B take
turns in sending messages. For example, when it is A's turn to send a message,
B is waiting for a message to arrive from A. B can not send any message before
it has received A's message. We begin here with a simplified form of this idea.

To make sure B doesn't send his message before A's message was received, B has
to include in his message a hash over A's message. A's message contains a
random nonce, therefore B can not produce a valid message until it receives A
message.

Therefore, the messages sent between A and B will be of the following format:

MoveToken

- contents
- oldToken
- randNonce

contents contains the actual message contents. oldToken is the hash over the
previously received message. randNonce is a randomly generated nonce, generated
by the sender of the message. The first ever message between A and B could be
initialized with a random value for oldToken. At any time, we call the party
whose turn to send a message the party that **holds the token**.

If the party A that holds the token doesn't have anything to send, it will wait.
This could block the remote party B (Who does not hold the token) from sending
messages. The remote B party could request access to the token by sending A a
message requesting the token:

RequestToken

- (empty)

A will then respond with a MoveToken message, possibly with empty contents. If
A believes that he does not own the token, A will send B the last MoveToken
message he sent B.

We call this form of communication between A and B a simple **Token Channel**.

To allow recovering from crashes of any of the parties and possible
communication problems, we add the following persistency feature: The last
MoveToken message seen is saved in long term memory. This could be the last
MoveToken message that was sent, or the last MoveToken message that was
received.

For atomicity, an outgoing MoveToken message is saved in long term memory
before it is sent. An incoming MoveToken message is saved in long term memory
only after it was fully processed.


A token channel keeps the following invariant: At any given time at most
one party belives that it "holds the token". 

Proof: Assume that the two parties A and B both believe that they "hold the token". 
This means that both A and B currently keep in their slot of long term memory a
received MoveToken message with corresponding oldToken values TA and TB.

The token values are a fully ordered chain of hashes, with some first token
value that was used to initialize the communication.

```
oldToken1 ---[A->B]--> oldToken2 ---[B->A]--> oldToken3 ---[A->B]--> oldToken4

oldToken1 = random
oldToken2 = hash(contents1 || oldToken1 || randNonce1)
oldToken3 = hash(contents2 || oldToken2 || randNonce2)
oldToken4 = hash(contents3 || oldToken3 || randNonce3)
```

Without loss of generality we assume that the token TA is at least as high on
the chain as the token TB.




## Interface with the Channeler

The Networker relies on the Channeler component for the ability to communicate
with the Networkers of direct neighbors. 

```
Networker             Networker
   |                     ^
   |                     |
   V                     |
Channeler ----------> Channeler
```

This is done using the messages:

**ChannelOpened** (Channeler -> Networker)

- remotePublicKey


**ChannelClosed** (Channeler -> Networker)

- remotePublicKey


**SendChannelMessage** (Networker -> Channeler)

- remotePublicKey
- tokenChannelIndex
- messageContent

 
**ChannelMessageReceived** (Channeler -> Networker)

- remotePublicKey
- messageContent



ChannelOpened is a message sent Channeler to the Networker, notifying that a
new communication channel is available from the Networker to the Networker of a
remote node. ChannelClosed message means that the channel was closed.

SendChannelMessage is a message sent from the Networker to the Channeler,
allowing to send a message to a Networker of a remote neighbor.
tokenChannelIndex is a hint to the Channeler, specifying the index number of
the token channel used for the underlying message. 

In case the Channeler is using an implementation of multiple TCP connections,
the tokenChannelIndex hint can be used to help divide messages to different TCP
connections to the remote neighbor.

ChannelMessageReceived is a message sent from the Channeler to the Networker,
notifying about the receipt of a new message from a Networker of a remote
neighbor.


Note that synchronization issues are possible: It is possible that the
Networker is sending a SendChannelMessage to the Channeler, while at the same time
the Channeler is sending a ChannelClosed message to the Networker. 

It might happen that the Networker and the Channeler have seen the events in
different order: The Channeler closed the TCP connections before the message
could be sent, while the Networker believes that he sent the SendChannelMessage
message to the Channeler before the channel was closed.

This is not a problem though, because the Networker uses token based communication.
The Networker always remembers the last message he attempted to send over a
token channel. If later the Networker finds that the remote Networker did not
received the message, it will send it again.

The Networker has the responsibility of configuring the Channeler.
This is done using the following messages:


**AddNeighborRelation**

- neighborPublicKey
- socketAddr (Optional)
- maxChannels

(TODO: This message is not exactly the same as the one in `inner_messages.rs`)

**RemoveNeighborRelation**

- neighborPublicKey


**SetNeighborMaxChannels**

- neighborPublicKey
- maxChannels


The message AddNeighborRelation allows to add a new neighbor with a few
parameters. neighborPublicKey is the public key of the remote neighbor.
socketAddr is an optional field, containing the remote IP and port of the
neighbor, used for TCP connection. If this field is left blank, the remote
neighbor is expected to know our address and initiate connection.
maxChannels should match the amount of token channels used to communicate with
this neighbor. This number will be used internally by the Channeler to optimize
the communication for the transport of token channels.

The message RemoveNeighborRelation removes a neighbor according to its public
key. The message SetNeighborMaxChannels changes the amount of maxChannels
parameter.


## Basic Networker configuration


The networker can be configured through the PluginManager component using the
following messages:


**AddNeighbor**

- neighborPublicKey
- socketAddr
- channelCapacity
- maxTokenChannels


**RemoveNeighbor**

- neighborPublicKey


**SetNeighborChannelCapacity**

- neighborPublicKey
- channelCapacity


**SetNeighborMaxTokenChannels**

- neighborPublicKey
- maxTokenChannels


The Networker's configuration is forwarded to the Channeler, in the form of the
corresponding messages: AddNeighborRelation, RemoveNeighborRelation,
SetNeighborMaxChannels.  Note that the Channeler is not given information about
channelCapacity of the token channels.

The Networker's configuration does not persist (It is kept on RAM). Therefore
the Networker has to be configured every time it is started through the
PluginManager component.









TODO:

- Service that Networker supplies to other components.
- The protocol between Networkers (Transported using the Channeler)
    - Dealing with invalid move token requests
- Dependence on the Funder for transfer of funds, to free communication capacity.
- The Networker multiplexes incoming messages to: IndexerClient, Funder,
    PluginManager
- Write about networker persistency
    - What should be persisted?
    - How to do this?



