# Paid packet switching protocol

## Abstract

TODO

## Intro

Assume a network of nodes (computers), where each node is directly connected to
a few other nodes. We want to be able to send messages between every two nodes
$x$ and $y$. We also want to compensate nodes that pass messages. A node that
wants to send a message will have to somehow pay the nodes that take part in
the message transfer.


## Switch interface

### Input messages

The switch is given an assymetric encryption component that can decrypt and
sign using the private key of the user.

**Initialize**

- currentTime

Initialize the state machine.


**TimeTick**

- currentTime

Information about the current time.


**ChannelOpened**

- channelId
- neighborPublicKey

A new channel was connected to the passerby switch.


**ChannelClosed**

- channelId
- neighborPublicKey

A channel was disconnected from the passerby switch.


**MsgFromChannel**

- channelId
- msg

Message was received from a given channel.

**SendMessage**

- destNodeIdent
- processingFee
- maxResponseLength
- maxDeliveryFee
- messageContent

A request to send a message to a remote node.
TODO: Should present a result, somehow.


**SendFund**

- destNodeIdent
- coreFund
- maxResponseLength
- maxDeliveryFee
- messageContent

A request to send fund to a remote node.
TODO: Should present a result, somehow.


### Output messages:

**MsgToChannel**

- channelId
- msg

A request to send message through channel channelId.

**MessageReceived**

- sourceNodePublicKey
- messageContent

**FundReceived**

- sourceNodePublicKey
- messageContent


Node id hashes are of size $120$ bits ($15$ bytes). This allows them to fit into
IPv6 address space of [private
addresses](https://en.wikipedia.org/wiki/Unique_local_address) (All ipv6
addresses that begin with the byte 0xfc).

The structure of msg in MsgFromPort and MsgToPort is as follows:

- messageType
- payload


## Channeler to Channeler messages

**InitChannel**

- randValue (128 bit)

This is the first message sent in a Channeler TCP connection by both sides.
If A wants to send B a message, A must know some recent randValue of B.


**EncMessage**

- keyDerivationNonce
- encryptedContent: Encrypt{key=derivedSymmetricKey, nonce=random}(
    recentRecipientRandValue, senderRandValue, messageContent)

Note that the remote public key should be known during the initialization of
the communication channel.

If any side of the connection receives an invalid EncMessage, the connection is
closed.


**KeepAlive** // EncMessage

Empty message. Used to provide recent rand values of the remote end of the
channel, and prove that the remote side is still alive.


**UserMessage** // EncMessage

- content



## Networker to Networker messages

A doubly signed path from `srcNodeId` to `dstNodeId` is of the form:

```
srcNodeId, 
sign{srcNodeId}(srcNodeId->a_1, timestamp)
sign{a_1}(a_1->srcNodeId, timestamp)
a_1
sign{a_1}(a_1->a_2, timestamp)
sign{a_2}(a_2->a_1, timestamp)
a_2
...
a_{k-1}
sign{a_{k-1}}(a_{k-1}->dstNodeId, timestamp)
sign{dstNodeId}(dstNodeId->a_{k-1}, timestamp)
dstNodeId
```

### Connection

**InitNeighborChannel**

- channelType
    - Management (There can be only one such channel)
        - maxTokenChannels
    - TokenChannel
        - tokenChannelIndex

This message is sent by the passive accepter of the connection.
It will determine the connection's type.

### Management Channel

**IndexerAnnounce**

- currentTime (UTC seconds since epoch)
- sign{key=ownerPublicKey}(signTime, indexerPublicKey)
- signChain, where every element is of the form:
    - currentNodePublicKey
    - sign(key=currentNodePublicKey}(prevSignature, nextNodePublicKey)

The first element in the chain of signatures is:
    - indexerPublicKey
    - sign(key=indexerPublicKey){currentTime, nextNodePublicKey)

Every node adds a new link.

This message is broadcasted from the indexer, and arrives at all the nodes
around it. This message is sent periodically from every indexer. 

Every node keeps a list of a few closest indexers. Every node also maintains an
approximation of the current time, as a median of all currentTime received from
indexers. The lastest currentTime is taken for every indexer.

A node forwards this message only if the sending indexer is in the list of the
closest indexers for this node.


### Neighbor token channel messages

**NeighborRequestToken**

- tokenIndex
- currentToken

The initiator of the channel sends this message if he doesn't own the token.
This is done to avoid deadlock, in case the other side also believes that he
doesn't own the token.

**NeighborMoveToken**

- transactions
- tokenIndex
- newM
- oldToken
- randNonce
- newToken: hash over all previous fields.


**NeighborInvalidMoveToken**

- badNeighborMoveTokenCopy
- reason



### Neighbor transactions

**NeighborTransaction** // NeighborMoveToken

- transactionId
- transactionType (1 byte). Possible values:
    - SetNeighborCapacity
    - LoadFunds
    - OpenNeighborTokenChannel
    - RequestSendMessage
    - ResponseSendMessage
    - CloseNeighborTokenChannel
- transactionLength (4 bytes)
- transactionContent


**SetNeighborCapacity** // NeighborTransaction // NeighborMoveToken

- newCapacity (Must be greater or equal to M).


**LoadFunds** // NeighborTransaction // NeighborMoveToken

- receipt (A receipt of payment, taken from ResponseSendFund)


**Message**

- senderPublicKey
- keyDerivationNonce
- encryptedContent: Encrypt{derivedSymmetricKey, nonce=random}(
    recipientTimestamp, senderTimestamp, messageType, messageContent)


messageTypes:

- UserMessage
- FriendRequestToken
- FriendMoveToken
- FriendInvalidMoveToken


**RequestSendMessage** // NeighborTransaction // NeighborMoveToken

- requestId
- requestContent: Message
- nodeIdPath
- processingFeeProposal 
- maxResponseLength
- deliveryFeeProposal
- amountTimeProposal


**ResponseSendMessage** // NeighborTransaction // NeighborMoveToken

- requestId
- responseContent: Message
- Signature{key=recipientKey}(requestId || requestContent ||
    nodeIdPath || processingFeeProposal || maxResponseLength || responseContent)



**FailedSendMessage** // NeighborTransaction // NeighborMoveToken

- requestId
- lastNodePublicKey
- Signature{key=lastNodePublicKey}(requestId || requestContent ||
    nodeIdPath || processingFreeProposal || maxResponseLength || responseContent)



## Funder to Funder messages

The following messages are sent over the Networker.


**FriendRequestToken** 

- currentToken


**FriendMoveToken** 

- transactions
- tokenIndex
- newM
- oldToken
- randNonce
- newToken: hash over all previous fields.

**FriendInvalidMoveToken**

- badFriendMoveTokenCopy
- reason


### Friends transactions

**FriendTransaction** // FriendMoveToken 

- transactionId
- transactionType (1 byte). Possible values:
    - SetFriendCapacity
    - OpenFriendTokenChannel
    - RequestSendFund
    - ResponseSendFund
    - CloseFriendTokenChannel
- transactionLength (4 bytes)
- transaction


**RequestSendFund** // FriendTransaction // FriendMoveToken 

- requestId
- requestContent: Message
- nodeIdPath
- coreFund
- maxResponseLength
- deliveryFeeProposal
- amountTimeProposal


**ResponseSendFund** // FriendTransaction // FriendMoveToken 

- requestId
- responseContent: Message
- Signature{key=recipientKey}(requestId || requestContent ||
    nodeIdPath || coreFund || maxResponseLength || responseContent)


**FailedSendFund** // FriendTransaction // FriendMoveToken 

- requestId
- lastNodePublicKey
- Signature{key=lastNodePublicKey}(requestId || requestContent ||
    nodeIdPath || coreFund || maxResponseLength || responseContent)



TODO:


- How to formalize connection/disconnection of FriendTokenChannel?
- Add Keepalive to TokenChannels using empty transactions list?

- How to properly unfriend someone?

- Should a node decide before sending how much funds to give to every node
    along the path? Or just hand over some amount of funds and hope for the
    best?

- How to negotiate the amount of TokenChannels to open?
    How to deal with TokenChannels that were closed in the middle (It is
    possible that funds are not balanced there).

- Split document into Neighbors and Friends parts?

- Add a mechanism for creating channels using UserMessage? A channel should
    have the following properties:
    - A beginning handshake message is probably not required.
    - Keepalive messages, to identify that the remote side has died.
    - Automatic maintanence of paths.
    - A channel should be one directional. 
    - Keepalive messages could be implemented even on a one directional channel
        because of the response.


